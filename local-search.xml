<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构和算法碎碎念</title>
    <link href="/algorithm/"/>
    <url>/algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="基础算法">基础算法</h2><h3 id="二分">二分</h3><p>第一次接触二分是在一个升序数组中快速找到一个值的下标。每次将当前部分的中间位置的元素值与想要查找的值进行对比，如果相等则结束；如果中间位置的元素值大于想要查找的值，则需要往左看；如果中间位置的元素值小于想要查找的值，则需要往右看。所以我将数组中的数进行分类：一类是小于 <code>target</code> 的数，一类是大于 <code>target</code> 的数，最后一类（个）是等于 <code>target</code> 的数。基于上面的原理可以写出以下的算法版本A，它在数组 <code>e</code> 的[l, r)区间查找 <code>target</code> 的下标，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>* e, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法有不完美的地方，在每次循环中，进行了两次条件的判断（即==和&lt;），但是直接命中 <code>target</code> 的概率是极低的，但是我们却用了一次计算专门去进行特判，严重影响了时间效率。比如说，循环进行了20次，最后找到了 <code>target</code> ，中间的判断是20 * 2 = 40次，但是对于==的判定有19次都是没用的，所以能否使用一个更高效的算法呢？</p><p>如果我们在循环中可以只用一次判断，这样就可以节省大量的时间。所以我将数组中的数进行重新分类：一类是小于等于 <code>target</code> 的数，一类是大于 <code>target</code> 的数。当中间元素的值小于等于 <code>target</code> 时，那么需要往右看（有可能取到中间值），反之往左看（不能取到中间值），最后我们返回的下标就是数组中小于等于 <code>target</code> 的最大值。只需要进行特判，如果这个值等于 <code>target</code> 则返回下标，否则返回-1。基于上面的原理可以写出以下的算法版本B，它在数组<code>e</code>的[l, r)区间查找 <code>target</code> 的下标，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>* e, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[mid] &lt;= target) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (e[l] == target) ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意比较版本A和B的循环退出条件的差异。</p><p>问题到这里呢，二分的问题就可以用一种特别的方式来思考，即分类的思想<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://www.acwing.com/activity/content/11/](https://www.acwing.com/activity/content/11/)">[2]</span></a></sup>。左边是满足某个条件的元素，右边是不满足某个条件的元素，而我们想要的答案一定是属于其中一类的（要么在左边要么在右边，上述的问题为左边），将二分出来的答案特判一下就能知道是否是我们想要的答案了（一般情况下不需要特判）。如<a href="https://www.acwing.com/problem/content/description/791/">https://www.acwing.com/problem/content/description/791/</a>。</p><p>答案在左边或者右边的写法是不一样的，如上述的问题，如果我们将分类设定为一类是小于 <code>target</code> 的数，一类是大于等于 <code>target</code> 的数，可以写出下面的代码版本C，它在数组 <code>e</code> 的[l, r)区间查找 <code>target</code> 的下标，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>* e, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[mid - <span class="number">1</span>] &gt;= target) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (e[l] == target) ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意版本B和C的区别，版本B中求出来的 <code>l</code> 是满足左边条件的最后一个数，版本C中求出来的 <code>l</code> 是满足右边条件的第一个数。本质区别在于版本C循环中比较的元素为 <code>e[mid - 1]</code> ，这是为什么呢？</p><p>那么有没有一种版本能够将版本B和C合并呢，即循环比较的元素不会因为答案在左边或右边进行变化？</p><p>二分的本质就是分类，如果我们可以找到左边和右边的分界点的话，问题就解决了。基于这样的原理和版本B的分类方式，我们有了下面的代码版本D，最后返回的 <code>l</code> 是 <code>&gt; x</code> 的第一个元素下标， <code>l - 1</code> 为 <code>&lt;= x</code> 的最后一个元素下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binsearch</span><span class="params">(<span class="type">int</span>* e, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[mid] &lt;= target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e[l - <span class="number">1</span>] == target ? l - <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于版本C的分类方式，我们有了下面的代码版本E，最后返回的 <code>l</code> 是 <code>&gt;= x</code> 的第一个元素下标， <code>l - 1</code> 为 <code>&lt; x</code> 的最后一个元素下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binsearch</span><span class="params">(<span class="type">int</span>* e, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e[l] == target ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上两个版本中 <code>l - 1</code> 是分类的左边的最后一个元素的下标，<code>l</code> 是分类的右边的第一个元素的下标。两者的唯一区别在于最后需要的下标是 <code>l</code> 还是 <code>l - 1</code> 。</p><h3 id="贪心">贪心</h3><h2 id="数据结构">数据结构</h2><h3 id="并查集">并查集</h3><p>并查集主要用于解决一些<strong>元素分组</strong>的问题，涉及到一些集合操作：</p><ul><li>合并：将两个不相交的集合合并为一个集合</li><li>查询：查询两个元素是否在同一个集合中</li></ul><h4 id="基本原理">基本原理</h4><p>并查集的重要思想在于，用集合里的一个元素代表集合（即根节点）。首先将所有元素的父节点设为它本身。如果需要合并，只需要将两个元素的其中一个根节点的父节点指向另外一个元素的根节点，此时两个元素的根节点相同，属于同一个集合。如果需要查询，只需要判断两个元素的根节点是否一致即可。可以看一个例子：</p><p><img src="../img/algorithm/disjoint_set.svg" alt="disjoint_set"></p><p>最开始的时候，所有元素的父节点设为它本身。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br></pre></td></tr></table></figure><p>如果需要将1和2所在的集合进行合并，那么只需要将2的父节点指向1（反过来也可），如下图所示</p><p><img src="../img/algorithm/disjoint_set1.svg" alt="disjoint_set1"></p><p>如果需要将2和3所在的集合进行合并，那么只需要将3的父节点指向2的根节点即可，如下图所示</p><p><img src="../img/algorithm/disjoint_set2.svg" alt="disjoint_set2"></p><p>如果需要查询2和3是否在一个集合，因为它们根节点相同，所以在同一个集合。而2和4的根节点不同，则它们不在同一个集合。</p><h4 id="路径压缩">路径压缩</h4><p>在合并的点越来越多时，从底部到根节点的距离将会越来越长，会有比较大的时间消耗。我们用路径压缩的方法来解决这一个问题：只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id=""></h4><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/index.htm">http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/index.htm</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.acwing.com/activity/content/11/">https://www.acwing.com/activity/content/11/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU 15-445(Fall 2022) project</title>
    <link href="/cmudb/"/>
    <url>/cmudb/</url>
    
    <content type="html"><![CDATA[<p>通过CMU 15-445学习了很多数据库底层的知识，在此做一个project的记录和一些自己对于数据库的理解。</p><p>我学习的版本是Fall 2022，原因有二：</p><ul><li>Fall 2022是Andy讲的，就是将数据库当作生命中第二重要事物的人（第一重要的是妻子）</li><li>BusTub的代码是在不断更新的，但是Fall 2022专门有一个release版本<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall](https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall)">[1]</span></a></sup>可以下载，这就显得十分方便了。</li></ul><h2 id="Project0-C-Primer">Project0: C++ Primer</h2><p>这个project主要是考查对C++的掌握程度，这个课程会用到C++17的语法，但是能够熟练使用C++11就完全足够了。</p><h2 id="Reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall">https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.1810(Fall 2022) lab</title>
    <link href="/mitos/"/>
    <url>/mitos/</url>
    
    <content type="html"><![CDATA[<p>学完这个课的第一感受：我之前学的是假的C语言？</p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习记录</title>
    <link href="/linux/"/>
    <url>/linux/</url>
    
    <content type="html"><![CDATA[<p>本文是在学习了AcWing的Linux基础课<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://www.acwing.com/activity/content/57/](https://www.acwing.com/activity/content/57/)">[1]</span></a></sup>之后的一点总结，加上了一些自己的理解。</p><h2 id="tmux">tmux</h2><p>tmux是一个神器，其主要功能有两点：第一是分屏，第二是使用<code>tmux a</code>可以回到原来的进度，继续运行进程（就算是断电断网这种极端情况都能恢复）。</p><p>我主要用到的tmux命令有以下几个：</p><ul><li><p><code>tmux</code> 新建一个tmux窗口</p></li><li><p><code>ctrl + a</code> 再按%，左右分屏</p></li><li><p><code>ctrl + a</code> 再按&quot;，上下分屏</p></li><li><p><code>ctrl + d</code> 关闭当前的光标所在的分屏</p></li><li><p><code>ctrl + a</code> 再按z，将当前分屏全屏/取消全屏</p></li><li><p><code>tmux a</code> 打开之前挂起的tmux窗口</p></li></ul><h2 id="vim">vim</h2><p>vim是一个命令行模式下的文本编辑器，可以通过设置一些快捷键提高开发的效率，完全脱离鼠标使用。这里我主要整理了一些常用的vim命令供自己回看。</p><p>使用方式：<code>vim &lt;filename&gt;</code> 如果该文件已经存在则打开它，否则创建它。</p><h3 id="模式">模式</h3><ul><li><p>标准模式：即进入vim的默认模式，需要通过命令来决定你下一步要干嘛。按下<code>:/?</code>三个字母中的任何一个，就可以在最下面看到一个命令行，输入命令后回车就可以完成你想要的操作，如查找、替换、保存、退出等。</p></li><li><p>编辑模式：在标准模式按下<code>i</code>，即可进入编辑模式，可以对文本进行编辑。在编辑模式下按<code>esc</code>可以返回标准模式。</p></li><li><p>文本选择模式：在标准模式按下<code>v</code>，即可进入文本选择，然后就可以通过选择文本进行一些快捷操作。按<code>esc</code>可以返回标准模式。</p></li></ul><h3 id="保存退出">保存退出</h3><ul><li><code>:wq</code> 保存并退出</li><li><code>:w</code> 保存</li><li><code>:w!</code> 强制保存</li><li><code>:w &lt;filename&gt;</code> 保存到一个新的文件filename</li><li><code>:q</code> 退出vim，只合适于未对文件做任何修改的情况下，否则无法退出。</li><li><code>:q!</code> 强制退出，丢弃已经有的修改</li></ul><h3 id="光标移动">光标移动</h3><ul><li><code>h</code> 往上移动；<code>l</code> 往下移动；<code>k</code> 往上移动；<code>j</code> 往下移动</li><li><code>n&lt;space&gt;</code> 输入一个数字n，再按下空格，光标会向右移动这一行的n个字符</li><li><code>0</code> 光标会移动到这行的开头</li><li><code>$</code> 光标会移动到这行的末尾</li><li><code>G</code> 光标会移动到最后一行</li><li><code>nG</code>（不需要按回车）或者 <code>:n</code>（需要按回车）光标移动到第n行</li><li><code>gg</code> 光标移动到第一行</li><li><code>n&lt;enter&gt;</code> 光标向下移动n行</li><li><code>w</code> 向右移动一个单词，光标将落在下一个单词的首字符；<code>e</code> 向右移动一个单词，光标将落在当前一个单词的最后一个字符（在这里，连续的数字+字母、特殊字符都会被视为一个单词。）</li><li><code>W</code> 向右移动一个单词，光标将落在下一个单词的首字符；<code>E</code> 向右移动一个单词，光标将落在当前一个单词的最后一个字符（在这里，vim会将空格作为单词的分隔符）</li><li><code>b</code> 向左移动一个单词，光标将落在上一个单词的首字符；<code>nb</code>向左移动n个单词；<code>ge</code>向左移动一个单词，移动到前一个单词的最后一个字符（这里的单词定义同<code>w</code>）</li><li><code>B</code> 向左移动一个单词，光标将落在上一个单词的首字符；<code>gE</code> 向左移动一个单词，光标将落在上一个单词的最后一个字符（这里的单词定义同<code>W</code>）</li><li><code>f&lt;target&gt;</code> 移动到当前行下一个target出现的位置；<code>F&lt;target&gt;</code> 移动到当前行上一个target出现的位置</li></ul><h3 id="查找">查找</h3><ul><li><code>/&lt;word&gt;</code> 在光标之下寻找第一个值为word的字符串</li><li><code>?&lt;word&gt;</code> 在光标之上寻找第一个值为word的字符串</li><li><code>n</code> 重复前一个查找操作</li><li><code>N</code> 反向重复前一个查找操作</li></ul><h3 id="替换">替换</h3><ul><li><code>:n1,n2s/&lt;word1&gt;/&lt;word2&gt;/g</code> 把n1到n2行之间的word1替换为word2</li><li><code>:1,$s/&lt;word1&gt;/&lt;word2&gt;/g</code> 全文替换</li><li><code>:1,$s/&lt;word1&gt;/&lt;word2&gt;/gc</code> 全文替换并且在替换时进行确认</li></ul><h3 id="删除复制">删除复制</h3><p>需要先进入文本选择模式</p><ul><li><code>d</code> 删除选中的文本</li><li><code>dd</code> 删除当前行</li><li><code>y</code> 复制选中的文本</li><li><code>yy</code> 复制当前行</li><li><code>p</code> 将复制/删除的文本在光标的下一行/下一个位置粘贴</li></ul><h3 id="撤销">撤销</h3><ul><li><code>u</code> 撤销</li><li><code>Ctrl + r</code> 取消撤销</li></ul><h3 id="文本缩进">文本缩进</h3><ul><li><code>&gt;</code> 将选中的文本整体向右缩进一次</li><li><code>&lt;</code> 将选中的文本整体向左缩进一次</li></ul><h3 id="其他">其他</h3><ul><li><code>:set paste</code> 设置成粘贴模式，取消代码自动缩进</li><li><code>:set nopaste</code> 取消粘贴模式，开启代码自动缩进</li><li><code>:set nu</code> 显示行号</li><li><code>:set nonu</code> 不显示行号</li><li><code>gg=G</code> 将全文代码格式化</li><li><code>ggdG</code> 删除全文</li></ul><h2 id="git">git</h2><p>git是一个开源的分布式版本控制系统。在平时的学习中，我会使用git来进行代码的版本控制，这一部分主要讲述常用的git命令。</p><h3 id="基本概念">基本概念</h3><ul><li>工作区：仓库的目录。工作区是独立于各个分支的，所有的分支都在同一个工作区。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的，所有的分支都使用同一个暂存区。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li><code>HEAD</code>: 指向当前版本的头指针。</li></ul><p>每形成一个新的版本，会在<code>HEAD</code>后面加上一个新的节点，将暂存区的内容存放在新的节点（但是暂存区不会清空），并将<code>HEAD</code>后移一位。这样就形成了一个树状结构，每一个点代表一个版本，由节点组成的整体叫做版本结构。</p><h3 id="常用命令">常用命令</h3><h4 id="config">config</h4><p>通常用于设置邮箱和用户名。有三个级别：<code>global</code>, <code>local</code>, <code>system</code>，默认不指定是<code>local</code>级别。前两个比较常用，<code>local</code>对应的是项目，可以在某个项目中设定特定的用户名和邮箱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &lt;name&gt;</span><br><span class="line">git config --local user.email &lt;email&gt;</span><br></pre></td></tr></table></figure><p><code>global</code>对应的是用户全局，这样在这个用户登陆这台电脑时，默认的邮箱和用户名就是用<code>global</code>设定的用户名和邮箱。</p><p>同时，上述的代码在不加入最后的参数时，可以查看当前的用户名和邮箱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name</span><br><span class="line">git config --local user.email</span><br></pre></td></tr></table></figure><h4 id="init">init</h4><p><code>git init</code> 在当前文件目录下创建git仓库，在本地生成一个.git隐藏文件夹。<code>git init &lt;path&gt;</code> 在特定目录下创建git仓库。</p><h4 id="add">add</h4><p>用来从工作区向暂存区添加变更。</p><p><code>git add .</code> 将工作区的所有文件都加入暂存区；<code>git add x</code> 将x文件添加到暂存区；<code>git add -u</code> 提交被修改和被删除文件，不包括新文件；<code>git add -A</code> 提交所有变化。</p><h4 id="status">status</h4><p><code>git status</code>查看仓库在暂存区和工作区的状态。</p><h4 id="commit">commit</h4><p>将暂存区的内容提交到当前分支。</p><p><code>git commit -m &quot;message&quot;</code> 提交一个描述为message的commit。</p><p><code>git commit -am &quot;message&quot;</code> 先提交所有变化到暂存区，然后提交一个描述为message的commit。注意：执行这条命令之前需要保证工作区的文件都在暂存区中。例如：新建一个文件，需要先add，再执行上述命令，不然会报错。</p><p><code>git commit --amend</code> 不增加一个新的commit的情况下将新修改的代码追加到前一次的commit中，并且会弹出一个编辑框，修改message信息。</p><p><code>git commit --amend --no-edit</code> 不增加一个新的commit的情况下将新修改的代码追加到前一次的commit中，并且不修改message信息。</p><h4 id="diff">diff</h4><p>比较文件的不同。注意以下的<code>&lt;file&gt;</code>都是文件，如果不加文件，默认比较整个工作区的文件。</p><p><code>git diff &lt;file&gt;</code> 查看文件在当前工作区相对于暂存区修改了哪些内容。</p><p><code>git diff --cached &lt;file&gt;</code> 查看文件在暂存区相对于最后一次commit修改了哪些内容。</p><p><code>git diff HEAD &lt;file&gt;</code> 查看文件在当前工作区相对于最后一次commit修改了哪些内容。</p><p><code>git diff &lt;commitId&gt;...&lt;commitId&gt; &lt;file&gt;</code> 查看文件在两次commit之间的修改。</p><p><code>git diff &lt;branch&gt;...&lt;branch&gt; &lt;file&gt;</code> 查看文件在两个分支上最后一次commit的不同。</p><h4 id="restore">restore</h4><p>撤销暂存区修改。</p><p><code>git restore &lt;file&gt;</code> 将文件尚未加入暂存区的修改全部撤销，会进行文件的修改。</p><p><code>git restore --staged &lt;file&gt;</code> 将暂存区回滚到上一个版本，文件不修改。</p><h4 id="log">log</h4><p>回顾提交历史。</p><p><code>git log</code> 查看从根节点到<code>HEAD</code>的整个路径。</p><p><code>git log --pretty=oneline</code> 将所有版本显示在一行。</p><p><code>git reflog</code> 查看<code>HEAD</code>指针的移动历史（包括被回滚的版本）。</p><p><code>git log --grep &lt;key&gt;</code> 查找包含指定字符串的commit。</p><p><code>git log -S &lt;key&gt;</code> 查找包含指定字符串的commit，这里指的文件里的key。</p><h4 id="reset">reset</h4><p>回滚代码。有三个常用参数：<code>--soft</code>，<code>--hard</code>,，<code>--mixed</code>，默认情况是<code>--mixed</code>。</p><p><code>git reset --soft [commitId]/&lt;branch&gt;</code> 将<code>HEAD</code>指针指向commitId，但是工作区和暂存区内容都不改变。</p><p><code>git reset (--mixed) &lt;commitId&gt;/&lt;branch&gt;</code> 将<code>HEAD</code>指针指向commitId，暂存区内容变为<code>HEAD</code>指针指向的内容，工作区内容不改变。</p><p><code>git reset --hard &lt;commitId&gt;/&lt;branch&gt;</code> 将<code>HEAD</code>指针指向commitId，工作区和暂存区内容都变为<code>HEAD</code>指针指向的内容。</p><p><code>git reset (--mixed) HEAD</code> 将暂存区的所有改动撤销到工作区。</p><p><code>git reset --hard HEAD^</code> 或<code>git reset --hard HEAD~</code> 将代码库回滚到上一个版本。</p><p><code>git reset --hard HEAD^^</code> 往上回滚两次，以此类推。</p><p><code>git reset --hard HEAD~100</code> 往上回滚100个版本。</p><h4 id="rm">rm</h4><p>删除文件。</p><p><code>git rm &lt;file&gt;</code> 删除工作区文件，并且将此次删除加入到暂存区。</p><p><code>git rm --cached &lt;file&gt;</code> 用于删除暂存区文件，并将此次删除放入暂存区，但会保留工作区的文件。将文件从仓库索引目录中删掉，文件还在，但是不归git管了。同时<code>git rm --cached -r .</code>指对所有文件进行操作。</p><h4 id="remote">remote</h4><p>管理远程连接。</p><p><code>git remote add &lt;name&gt; &lt;url&gt;</code> 添加远程仓库关联。</p><p><code>git remote remove &lt;name&gt;</code> 删除远程仓库关联。</p><p><code>git remote rename &lt;old_name&gt; &lt;new_name&gt;</code> 更名远程仓库关联。</p><p><code>git remote show &lt;name&gt;</code> 显示某个远程仓库的信息。</p><h4 id="push">push</h4><p>将本地版本库推送到远程分支。</p><p><code>git push -u &lt;remote&gt; &lt;branch&gt;</code> 将当前分支推送到远程仓库并绑定（往往是在第一次push时使用）。</p><p><code>git push &lt;remote&gt; &lt;branch&gt;</code> 将当前分支推送到远程仓库。</p><p><code>git push -d &lt;remote&gt; &lt;branch&gt;</code>或者<code>git push &lt;remote&gt; :&lt;branch&gt;</code> 删除远程仓库的分支。</p><p><code>git push --set-upstream &lt;remote&gt; &lt;branch&gt;</code> 设置本地分支对应远程仓库的branch分支。</p><h4 id="clone">clone</h4><p>克隆远程仓库代码。注意：clone下来的文件夹与push上去在某些东西存在差异如<code>HEAD</code>指针的来回移动就看不到，如<code>remote</code>的name将恢复默认的<code>origin</code>等</p><p><code>git clone &lt;url&gt;</code> 克隆，文件夹名为远程仓库的名字。</p><p><code>git clone &lt;url&gt; &lt;dir_name&gt;</code> 取一个自己想要的名字。</p><h4 id="branch">branch</h4><p>分支操作。</p><p><code>git branch</code> 查看本地所有分支。</p><p><code>git branch -a</code> 查看所有分支列表，包括本地和远程。</p><p><code>git branch &lt;name&gt;</code> 新建分支。</p><p><code>git branch &lt;name&gt; &lt;commitId&gt;</code> 在指定commit上创建分支。</p><p><code>git branch -d &lt;name&gt;</code> 删除本地分支，如果在分支中有一些未merge的提交则会失败。</p><p><code>git branch -m &lt;oldName&gt; &lt;newName&gt;</code> 重命名分支。</p><p><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote_branch&gt; &lt;local_branch&gt;</code>：将远程的分支与本地的分支对应。</p><h4 id="checkout">checkout</h4><p>切换分支。</p><p><code>git checkout &lt;branch&gt;</code> 切换到已有的分支。</p><p><code>git checkout -b &lt;branch&gt;</code> 新建分支并且切换到该分支。</p><p><code>git checkout -b &lt;branch&gt; &lt;commitId&gt;</code> 在指定commit上新建分支并切换到该分支。</p><p><code>git checkout -t &lt;remote&gt;/&lt;branch&gt;</code> 将远程的分支拉取到本地。</p><p><code>git checkout .</code> 放弃工作区所有文件的修改。</p><h4 id="merge">merge</h4><p>将两个或以上的开发版本进行合并。</p><p><code>git merge &lt;branch&gt;</code> 合并branch分支到当前分支。</p><p><code>git merge --abort</code> 退出merge过程，常在处理冲突时使用。</p><p><code>git merge --continue</code> 继续 merge 过程，常在处理完冲突时使用。</p><p><code>git merge --squash &lt;branch&gt;</code> 合并分支上的多个commit合并成一个commit叠加在当前分支上即当前分支不会增加新的commit。</p><h4 id="rebase">rebase</h4><p>变更某个分支。</p><p><code>git rebase &lt;branch&gt;</code> 变更某个分支。</p><p><code>git rebase --abort</code> 退出rebase过程，常在处理冲突出错时使用。</p><p><code>git rebase --continue</code> 继续rebase过程，常在处理完冲突时使用。</p><p>使用：两个分支master和dev不一致需要将dev上的修改合并到master上</p><ul><li>先切换到dev分支，执行<code>git rebase master</code>，这一步将dev的commit复制，内容进行合并，可能会处理冲突。不会产生新的节点</li><li>然后切换到master分支，执行<code>git merge dev</code>，一定不会处理冲突，且合并之后直接将HEAD指针移到<code>dev</code>的头即可，不会产生新的节点，dev和master在同一个位置</li></ul><p>举个例子说明<code>rebase</code>和<code>merge</code>的区别：</p><ul><li>假如两个分支master和dev都进行了修改，并且commit了，现在要将dev上的修改合并到master上，可以在master分支直接使用<code>git merge dev</code>，但是<code>merge</code>合并会产生一个新的节点，dev和master不在同一个位置。</li><li>而<code>rebase</code>合并不会产生一个新的节点且dev和master在同一个位置，这样方便下次分别开发。</li></ul><h4 id="pull">pull</h4><p>从远程获取代码并且合并本地的版本。</p><p><code>git pull &lt;remote&gt; &lt;remote_branch&gt;:&lt;local_branch&gt;</code> 使用merge方式将远程remote的remote_branch分支与本地的local_branch进行合并。也可以直接使用<code>git pull</code>即将远程的默认分支（一般是main）与本地所在分支进行合并。</p><p><code>git pull --rebase &lt;remote&gt; &lt;remote_branch&gt;:&lt;local_branch&gt;</code> 使用rebase方式将远程remote的remote_branch分支与本地的local_branch进行合并。</p><h4 id="stash">stash</h4><p>保存和恢复工作进度。</p><p><code>git stash save message</code> 将工作区和暂存区中尚未提交的修改存入栈中，并且工作区和暂存区的内容将恢复到上次commit的内容。message是此次进度保存的说明，可以不加<code>save message</code>，此时的默认message是上次commit的message。</p><p><code>git stash show -p</code> 显示此次工作进度做了哪些具体的代码改动。</p><p><code>git stash pop</code> 恢复工作到工作区，并且删除栈顶元素。</p><p><code>git stash drop</code> 删除栈顶存储的修改。</p><p><code>git stash list</code> 查看栈中所有的元素。</p><h2 id="ssh">ssh</h2><p>ssh是一种网络通信协议，可使两台计算机进行通信和共享数据。</p><h3 id="ssh使用">ssh使用</h3><h4 id="远程登录">远程登录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure><ul><li><code>user</code>：用户名</li><li><code>hostname</code>：IP地址或域名</li></ul><p>退出输入 <code>logout</code> 或者ctrl + d</p><p>如果需要指定端口，则需要使用<code>-p</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname -p 22</span><br></pre></td></tr></table></figure><h4 id="别名登陆">别名登陆</h4><p>创建文件在<code>~/.ssh/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host myserver</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名 <code>myserver</code></p><h4 id="密钥登陆">密钥登陆</h4><p>创建密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>执行结束后，~/.ssh/目录下会多两个文件：</p><ul><li><code>id_rsa</code> 私钥</li><li><code>id_rsa.pub</code> 公钥</li></ul><p>想免密登录 <code>myserver</code> 服务器。则将公钥中的内容，复制到 <code>myserver</code> 中的 <code>~/.ssh/authorized_keys</code> 文件里即可。</p><p>也可以使用 <code>ssh-copy-id myserver</code> 一键添加公钥</p><h3 id="scp使用">scp使用</h3><p>使用scp可以在两台主机之间进行文件传输，命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure><p>将 <code>source</code> 文件复制到 <code>destination</code></p><p>一次性复制多个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source1 source2 destination</span><br></pre></td></tr></table></figure><p>复制文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure><p>指定服务器的端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 22 source1 source2 destination</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.acwing.com/activity/content/57/">https://www.acwing.com/activity/content/57/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://imageslr.com/2021/vim.html">https://imageslr.com/2021/vim.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/OneSizeFitsQuorum/git-tips">https://github.com/OneSizeFitsQuorum/git-tips</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61C(Spring 2023) lab and project</title>
    <link href="/cs61c/"/>
    <url>/cs61c/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab">Lab</h2><h3 id="Lab1-C">Lab1 C</h3><p>这个lab考查了C语言的基本使用，知道C语言的基本语法就没啥难度。</p><h4 id="Ex1">Ex1</h4><p>主要使用gcc编译c程序，并且按照要求修改代码</p><h4 id="Ex2">Ex2</h4><p>指针的简单使用。</p><h4 id="Ex3">Ex3</h4><p>对于值传递的考查，在c语言中，任何传递都是值传递，在函数中会复制一份和原来数值相同的变量。如果在某个函数中想要改变某个参数的值，需要使用指针，在C++中可以使用引用。</p><h4 id="Ex4">Ex4</h4><p>堆区的空间申请，在一个作用域里，数据几基本上都在栈上，是系统回收内存。如果需要使用堆区的空间，需要自己申请，并且需要自己回收。</p><h4 id="Ex5-Ex6">Ex5-Ex6</h4><p>数组与指针：数组是对一段连续空间的管理，而数组名是指向数组首地址的指针。可以通过指针访问数组的任何一个元素（注意不能越界，否则会出现错误），但是它无法自增或自减。</p><h4 id="Ex7">Ex7</h4><p>字符串和指针：c语言的字符串是由一系列字符组成的段。字符串的名字是指向首个字符地址的指针，可以通过该指针访问到字符串的任何元素，同样它也不能自增或者自减。同时，在字符串的末尾需要加上<code>\0</code>，表明已经到字符串的末尾了。</p><h4 id="Ex8">Ex8</h4><p>结构体：结构体变量用<code>.</code>来拿出里面的元素或者方法，结构体指针使用<code>-&gt;</code>，也可以先解引用再用<code>.</code>。</p><h4 id="Ex9">Ex9</h4><p>二级指针：指针的指针，二级指针指向的值是另一个值的地址，一定要先有一级指针才有二级指针，否则容易出现错误。</p><h4 id="Ex10">Ex10</h4><p>一个链表判断是否存在环，如果是C++可以使用hash表判断一个节点是否重复出现。C语言中没有高级的数据结构实现，这里考虑使用快慢指针，在一个环中，走得快的一定会和走得慢的在某个时间相遇，如果不成环，走得快的会先到终点，无法相遇。</p><h3 id="Lab2-C-Debugging">Lab2 C Debugging</h3><p>这个lab主要考查C语言的内存管理和gdb的使用。</p><h4 id="Ex1-2">Ex1</h4><p>找到源文件的警告，并且更正。</p><ul><li>第一处警告是在<code>new_course-&gt;name = *name;</code>处，这里的<code>name</code>是一个<code>char*</code>类型，<code>*name</code>则是<code>name</code>的首个字符，属于是<code>char</code>类型，而<code>Course</code>的<code>name</code>成员也是<code>char*</code>类型，类型不匹配。</li><li>第二处警告是在<code>return &amp;new_course;</code>处，这里的<code>new_course</code>是<code>Course*</code>类型，其地址为<code>Course**</code>类型，这里应该直接返回<code>new_course</code>。</li></ul><h4 id="Ex2-2">Ex2</h4><h3 id="Lab3-RISC-V-Venus">Lab3  RISC-V, Venus</h3><h3 id="Lab4-RISC-V-Calling-Convention">Lab4 RISC-V Calling Convention</h3><h2 id="Project">Project</h2><h3 id="Project1-snek">Project1: snek</h3><p>这个project用C语言实现一个简单的贪吃蛇游戏，考察C语言和GDB的掌握，涉及到结构体，指针，数组，内存分配，字符串等知识。</p><h4 id="准备工作">准备工作</h4><h5 id="背景知识">背景知识</h5><ol><li>在一个用<code>#</code>围起来的区域里有蛇，食物和墙。</li><li>每条蛇分为三个部分：头、身体、尾</li></ol><ul><li><code>WASD</code>表示头的朝向</li><li><code>^&lt;v&gt;</code>表示身体的朝向</li><li><code>wasd </code>表示尾的朝向</li></ul><ol start="3"><li><code>#</code>表示墙，蛇撞到就会判断为死亡，并且此时的头会被替换为<code>x</code>。</li><li><code>*</code>表示食物，当食物被蛇吃掉后，蛇的长度会加1，该区域中会随机出现一个新的食物。</li></ol><h5 id="The-game-state-t-struct">The <code>game_state_t</code> struct</h5><p>A snake game is stored in memory in a <code>game_state_t</code> struct. The struct contains the following fields:</p><ul><li><code>unsigned int num_rows</code>: The number of rows in the game board.</li><li><code>char** board</code>: The game board in memory. Each element of the <code>board</code> array is a <code>char*</code> pointer to a character array containing a row of the map.</li><li><code>unsigned int num_snakes</code>: The number of snakes on the board.</li><li><code>snake_t* snakes</code>: An array of <code>snake_t</code> structs.</li></ul><h5 id="The-snake-struct">The <code>snake</code> struct</h5><p>Each <code>snake</code> struct contains the following fields:</p><ul><li><code>unsigned int tail_row</code>: The row of the snake’s tail.</li><li><code>unsigned int tail_col</code>: The column of the snake’s tail.</li><li><code>unsigned int head_row</code>: The row of the snake’s head.</li><li><code>unsigned int head_col</code>: The column of the snake’s head.</li><li><code>bool live</code>: true if the snake is alive, and false if the snake is dead.</li></ul><h4 id="Task1-create-default-state">Task1: <code>create_default_state</code></h4><p>根据题目所给的图形初始化<code>game_state_t</code>和<code>snake</code>。根据图形可以得知行与列，蛇的数量，蛇的位置，食物的位置。根据已知的信息进行赋值即可。</p><p>需要注意的是，给字符串开空间的时候一定要多开一个空位给<code>\0</code>留位置。</p><h4 id="Task2-free-state">Task2: <code>free_state</code></h4><p>释放堆空间，记住一点：哪里用<code>malloc</code>申请了堆空间就一定要用<code>free</code>释放。同时在释放之前一定要记得判空，因为<code>free</code>如果传入了一个空指针会出现不可预知的错误。</p><h4 id="Task3-print-board">Task3: <code>print_board</code></h4><p>将<code>game_state_t</code>的图形写在某个文件里。这里需要使用<code>fprintf</code>函数，它和<code>printf</code>的唯一区别在于<code>fprintf</code>的第一个参数是指向需要写入的文件，而<code>printf</code>是直接输出到命令行的。只要知道了这个原理，这个题将和在命令行中打印图形的思路一模一样了。</p><h4 id="Task4-update-state">Task4: <code>update_state</code></h4><h5 id="Task4-1-Helper">Task4.1: Helper</h5><p>主要是完成一些辅助函数：</p><ul><li><code>bool is_tail(char c)</code>判断是否为尾，只需要判断<code>c</code>是否是尾的那几个字母即可</li><li><code>bool is_head(char c)</code>判断是否为头，同上</li><li><code>bool is_snake(char c)</code>是否为头，或者尾，或者为身体或者为<code>x</code></li><li><code>char body_to_tail(char c)</code>、<code>char head_to_body(char c)</code>、<code>unsigned int get_next_row(unsigned int cur_row, char c)</code>、<code>unsigned int get_next_col(unsigned int cur_col, char c)</code>根据提示翻译成代码即可</li></ul><h5 id="Task4-2-next-square">Task4.2: <code>next_square</code></h5><p>根据蛇的状态确定蛇即将移动到的单元格的字符。首先根绝蛇的头的横纵坐标和方向确定即将移动到的单元格的横纵坐标，从<code>state</code>中取出该坐标对应的字符即可。</p><h5 id="Task4-3-update-head">Task4.3: <code>update_head</code></h5><p>更新头。设蛇头即将移动的单元格为<code>x</code>，当前的头为<code>y</code>。根据<code>y</code>的坐标和字符可以算出<code>x</code>的坐标，然后将<code>y</code>的字符赋给<code>x</code>。同时<code>y</code>的字符需要更新成与<code>x</code>的字符同方向的对应的身体的字符即<code>^&lt;v&gt;</code>。最后需要更新该蛇的头的坐标。</p><h5 id="Task4-4-update-tail">Task4.4: <code>update_tail</code></h5><p>更新尾。设蛇尾即将移动的单元格为<code>x</code>，当前的尾为<code>y</code>。根据<code>y</code>的坐标和字符可以算出<code>x</code>的坐标，然后将<code>x</code>的字符更新为当前<code>x</code>的字符相对应的尾的字符即<code>wasd</code>。同时<code>y</code>的字符需要更新为空格。最后需要更新该蛇的尾的坐标。</p><h5 id="Task4-5-update-state">Task4.5: <code>update_state</code></h5><p>根据<code>state</code>更新每条蛇的状态，首先使用<code>next_square</code>函数计算出蛇即将移动到的单元格的字符，然后分类讨论，分为以下三种情况：</p><ul><li>如果字符为空，则蛇直接移动到该点，头尾都需要更新。</li><li>如果字符为<code>*</code>，蛇遇到了食物，吃掉，更新头，最后在区域中添加一个新的食物</li><li>如果字符为<code>#</code>，遇到墙，将当前头的字符设为<code>x</code>，改变蛇的生存状态。</li></ul><h4 id="Task5-load-board">Task5: <code>load_board</code></h4><p>根据文件加载<code>state</code>。这题我认为是这个project最难的一题（当然和我不熟悉C语言的文件操作有很大的关系）。同时这题不需要更新蛇的状态，难度减小了不少。</p><p>首先将文件读入到一个字符串中，接下来的任务就是将字符串写入到<code>state</code>的<code>board</code>中去。根据字符串换行的数量确定图形的行数，进而根据行数给<code>state</code>的<code>board</code>开空间。</p><p>然后我利用了一个双指针算法，一个指针指向当前行的头，另一个指针往后查询，如果查询到为<code>\n</code>，则完整的一行找到了，给当前行开空间（一定要多开一个，因为要在末尾添加<code>\0</code>），最后将字符串复制过去，更新第一个指针的位置。以此类推将整个区域加载出来。</p><h4 id="Task6-initialize-snake">Task6: <code>initialize_snake</code></h4><p>根据所给的<code>state</code>确定蛇的状态。</p><h5 id="Task6-1-find-head">Task6.1: <code>find_head</code></h5><p>根据所给蛇的状态和尾的坐标找到头的坐标。因为每一个坐标都有一个方向，直接根据该方向往前推，知道确定该节点的字符为头代表的字符即可（<code>WASD</code>）。</p><h5 id="Task6-2-initialize-snake">Task6.2: <code>initialize_snake</code></h5><p>先扫描整个区域，通过有多少<code>wasd</code>的存在确定蛇的数量进而确定所需要开设的空间。然后根据每条蛇的尾位置找到头，这样就确定了蛇的头尾坐标。最后根据头的字符判断蛇是否死亡即可。</p><h4 id="Task7-main">Task7: <code>main</code></h4><p>根据提示完成主函数。</p><p>到此整个project已经写完了，整体的感受是难度适中，考查的知识点非常全面，基本上涵盖平时在C语言中遇到的所有语法，体验很不错。</p><h3 id="Project2-CS61Classify">Project2: CS61Classify</h3><p>Project2用RISC-V汇编写一个神经网络，用来识别MNIST手写数字，主要考查对于汇编的掌握和相关寄存器的使用。</p><h4 id="Task1-Absolute-Value">Task1: Absolute Value</h4><p>这个Task是个演示Task，主要教你如何在venus中如何调试汇编代码。绝对值函数的实现：首先需要将数据加载到寄存器中；比较其与0的大小，大于0则什么也不做直接返回，小于0则取反，并将绝对值再写入原地址中。</p><h4 id="Task2-ReLU">Task2: ReLU</h4><p>实现ReLU函数：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(x) = \begin{cases}  x &amp; x \ge 0 \\0 &amp; x &lt; 0\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>函数会传入两个参数：一个数组的首地址<code>a0</code>和数组的长度<code>a1</code>，需要完成计算数组的所有元素的ReLU值并保存在原地（就地修改）。如果数组长度小于1则返回错误。</p><p>基本思路如下：先将<code>a1 &lt; 1</code>直接返回。然后用一个变量<code>x</code>来保存<code>a1</code>，每来一次循环，比较<code>a0</code>的值与0的大小关系，如果<code>a0 &gt;= 0</code>，则不做任何变化，否则将0写入到对应的内存。最后执行<code>x = x - 1</code>，数组指针<code>a0 = a0 + 4</code>，直到<code>x == 0</code>时终止循环。</p><h4 id="Task3-Argmax">Task3: Argmax</h4><p>寻找数组中最大值对应的下标，如果存在多个最大值则返回第一个出现的下标。函数会传入两个参数：一个数组的首地址<code>a0</code>和数组的长度<code>a1</code>，需要返回一个参数<code>a0</code>为最大值对应的坐标。</p><p>基本思路如下：先判异常。初始化变量<code>x = 0</code>表示当前访问的数组下标，<code>y = a0[0]</code>表示当前的最大值，<code>z = 0</code>表示当前最大值的下标。每来一次循环，将<code>a0</code>的值与<code>y</code>的值进行比较，如果<code>a0</code>的值小于等于<code>y</code>的值，则不做任何处理；否则将<code>y</code>和<code>z</code>进行更新。最后执行<code>x = x + 1</code>，数组指针<code>a0 = a0 + 4</code>，直到<code>x == a1</code>时终止循环。</p><h4 id="Task4-Dot-Product">Task4: Dot Product</h4><p>计算两个向量的内积。函数会传入5个参数：第一个数组的首地址<code>a0</code>、对应的步长<code>a3</code>；第二个数组的首地址<code>a1</code>、 对应的步长<code>a4</code>，每个数组需要用的元素个数<code>a2</code>。需要返回一个参数<code>a0</code>为两个向量的内积。</p><p>基本思路如下：先判异常。初始化变量<code>x = 0</code>表示当前访问的数组下标，<code>y = 0</code>表示当前的和。每来一次循环，将<code>a0</code>和<code>a1</code>的值相乘的结果加到<code>y</code>上。然后执行<code>a0 = a0 + 4 * a3</code>、<code>a1 = a1 + 4 * a4</code>，直到<code>x == a2</code>时终止循环。</p><h4 id="Task5-Matrix-Multiplication">Task5: Matrix Multiplication</h4><p>计算矩阵相乘的结果。函数会传入7个参数：第一个数组的首地址<code>a0</code>、行数<code>a1</code>、列数<code>a2</code>；第一个数组的首地址<code>a3</code>、行数<code>a4</code>、列数<code>a5</code>；存储答案的数组的首地址<code>a6</code>。</p><p>基本思路如下：先判异常。这里计算内积需要调用Task4的轮子。初始化变量<code>x = 0</code>表示第一个矩阵的行数，<code>y = 0</code>表示第二个矩阵的列数。根据Task4的要求将参数赋值：</p><ul><li><code>a0</code>应该为第一个矩阵的每行首个元素的地址</li><li><code>a1</code>为第二个矩阵的每列首个元素的地址</li><li><code>a2</code>为元素格式即第一个矩阵的列数或者第二个矩阵的行数</li><li><code>a3</code>为第一个向量的步长即1</li><li><code>a4</code>为第二个向量的步长即第二个矩阵的列数</li></ul><p>调用<code>dot</code>，将算出来的结果存放在<code>a6</code>，将<code>a6</code>往后移动一位，再执行<code>y = y + 1</code>，直到<code>y == a5</code>为止结束内层循环，然后需要将指向第一个矩阵的指针移到下一行的开头，最后执行<code>x = x + 1</code>，直到<code>x == a1</code>结束外层循环。</p><p><strong>注意</strong>：因为在函数中调用了<code>dot</code>，<code>ra</code>会发生变化，所以需要先保存<code>ra</code>的值。</p><h4 id="Task6-Testing">Task6: Testing</h4><p>编写一些测试函数。根据每个函数的输入和py文件上的提示直接写即可。</p><h3 id="Project3-CS61CPU">Project3: CS61CPU</h3><p>这个Project会搭建一个二级流水线的CPU，并在上面运行RISC-V汇编代码。主要考查的内容有组合逻辑电路，Flip-Flop，RISC-V指令的表示。</p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://cs61c.org/sp23/">https://cs61c.org/sp23/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Structrue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
